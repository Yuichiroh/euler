package nlp.scala.euler

import nlp.scala.util.Stopwatch
import nlp.scala.util.Stopwatch

object P29 extends App {
  /**
   * Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
   *
   * 2^2=4, 2^3=8, 2^4=16, 2^5=32
   * 3^2=9, 3^3=27, 3^4=81, 3^5=243
   * 4^2=16, 4^3=64, 4^4=256, 4^5=1024
   * 5^2=25, 5^3=125, 5^4=625, 5^5=3125
   * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
   *
   * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
   *
   * How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
   */

  val max = args(0).toInt

  /** greedy way */
  val sw = new Stopwatch
  val tmp = for {
    a <- 2 to max
    b <- 2 to max
  } yield BigInt(a).pow(b)
  println(tmp.distinct.size.toString)
  println(sw.readSplit)

  /** べき乗数のところだけ全列挙して重複チェック */
  def perfectPower(n: Int) = Iterator.from(1).map(BigInt(n).pow(_))
  def perfectPowers(max: Int) = Iterator.from(2).map(perfectPower(_).takeWhile(_ <= max).toList)

  val sw2 = new Stopwatch
  val powers = perfectPowers(max).takeWhile(_.size > 1).toList.flatten.distinct
  val duplicatedBaseSize = powers.size
  val tmp2 = for {
    a <- powers
    b <- 2 to max
  } yield a.pow(b)
  println((max - 1 - duplicatedBaseSize) * (max - 1) + tmp2.distinct.size)
  println(sw2.readSplit)

  //  var c = 1
  //  val sum = for {
  //    powers <- perfectPowers(max).takeWhile(!_.isEmpty)
  //  } yield {
  //    c = c + 1
  //    val list = powers.toList
  //    println(list.zipWithIndex)
  //    println(list.size)
  //    //    val count = list.zipWithIndex.map(n => duplicated(n._2 + 2))
  //    //    println(count)
  //    //    println(count.sum)
  //    //    count.sum
  //  }
  //  println(sum.sum)
  //
  //  def duplicated(power: Int) = {
  //    val count = Array.fill(max)(false)
  //    for (n <- 1 to power) {
  //      for (m <- Iterator.from(1).map(_ * n).takeWhile(_ <= max))
  //        count(m - 1) = true
  //    }
  //    count.toList.filter(e => e).size
  //  }
  //
  //  def difference(n: Int, m: Int) = (max - 1) / n //XXX

  //  val memo = collection.mutable.Map[BigInt, (Int, Int)]()

  /**
   * もし、今までにべき乗として出現していない数があれば、max-1個の新たな数が生成される。
   * べき乗数として出現しているならば、最大の底を取って、a^bと表せるとすると、max - max/b個の新たな数が生成される。
   * XXX 2^2と2^3など、複数の置き換え可能な底にかんして、重複がある XXX
   */
  //  val tmp = (2 to max).map(a => {
  //    val result = Iterator.from(1).takeWhile(n => BigInt(a).pow(n) < 100)
  //    result.foreach(e => memo(BigInt(a).pow(e)) = (a, e))
  //  })

}